# Q9 3Sum

12/02 p14 q15

## Q
Given an integer array nums, return all the triplets ```[nums[i], nums[j], nums[k]]``` such that ```i != j, i != k```, and ```j != k```, and ```nums[i] + nums[j] + nums[k] == 0.```  
  
Notice that the solution set must not contain duplicate triplets.

## Sample Input

Input: nums = [-1,0,1,2,-1,-4]   
Output: [[-1,-1,2],[-1,0,1]]

Input: nums = []  
Output: []

Input: nums = [0]  
Output: []

## Constraints
- 0 <= nums.length <= 3000
- -105 <= nums[i] <= 105

## 1. My Solution <- Given Solution #1
```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        ans = []
        nums.sort() #idx is useless so sort it in order to use two-pointer + a

        for i in range(len(nums)-2): #'cause next two elements i, i+1, i+2
            if i>0 and nums[i]==nums[i-1]: #when current value is same as the previous one, skip it!
                continue
            
            left, right = i+1, len(nums) - 1 #loop with i then beyond i idx, two-pointer sol begins.
            
            while left < right:
                sums = nums[i] + nums[left] + nums[right]
                if sums > 0:
                    right -= 1
                elif sums < 0:
                    left += 1
                else:
                    ans.append([nums[i], nums[left], nums[right]])
                    
                    '''
                    the most important part in this sol.
                    #after you sort the input list, there will be duplicated values.
                    Skipping these valeus will be the main point to decrease the time.
                    Therefore, continuously repeat moving pointer.
                    '''
                    while left < right and nums[left] == nums[left+1]:
                        left += 1 #even if left +=1 but same situation, repeat it
                    while left < right and nums[right] == nums[right-1]:
                        right -= 1 #vice versa               
                    
                    right -= 1 #why moved both? It is 'cause sum is 0 anyway. only moving one pointer is same as before. 
                    left += 1
        return ans

ans = Solution()
nums = [-1,0,1,2,-1,-4]
#nums = [0]
pt = ans.threeSum(nums)
print(pt)
```

[Using two-pointer]  


## Overall Review



