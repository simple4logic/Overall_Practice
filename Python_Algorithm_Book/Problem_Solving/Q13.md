# Q13 Palindrome Linked List

12/10 p201 Q234

## Q

Given the `head` of a singly linked list, return `true` if it is a palindrome.

## Sample Input

![image](https://user-images.githubusercontent.com/68508521/145584967-2437e017-8b55-4d85-a491-363cef18c458.png)

Input: head = [1,2,2,1]  
Output: true

![image](https://user-images.githubusercontent.com/68508521/145585037-dea2c6f3-a8f8-4239-9c5f-5e9f37ab7d41.png)

Input: head = [1,2]  
Output: false

## Constraints
- The number of nodes in the list is in the range [1, 10<sup>5</sup>].
- 0 <= Node.val <= 9


## 1. My Solution <- Given Solution #1
```py
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if not head:
            return True #to prevent when input is 0 node. "But" in this Q, it's meaningless

        ansl :list = []
        node = head

        while node is not None:
            ansl.append(node.val)
            node = node.next

        while len(ansl)>1: #if len = 1, stop. Actually single letter left so true.
            if ansl.pop(0) != ansl.pop():
                return False
        
        return True

#To test, you have to make to linked-list manually.
#In the problem, it makes the linked list automatically
inp = [1,2,2,1] #inp = input as head

head = ListNode(inp[0])
node1 = ListNode(inp[1])
node2 = ListNode(inp[2])
node3 = ListNode(inp[3])
head.next = node1
node1.next = node2
node2.next = node3 #node3's next is none.
'''
to make it shorten, do like this
node3 = ListNode(inp[3])
node2 = ListNode(inp[2], node3)
node1 = ListNode(inp[1], node2)
head = ListNode(inp[0], node1)
'''

#for test
a = Solution()
a.isPalindrome(head)
```

The concept itself is definitely simple. Move values in the linked list to the single list. Then do as we did before.  

Before we start, to be familiar with linked list, take a time to understand. Let's see the code below the funtion, starting with "#To test~". I made a linked list, based on the given `head`. The object ListNode is an __address__ itself, and get two value as arguments: value and the address of the next node. Therefore node = node.next is assigning address of the next one to the current one. 


## 2. Given Soltuion #2
```py
def isPalindrome(self, head: ListNode) -> bool:
        if not head:
            return True

        ansl :Deque = collections.deque()
        node = head

        while node is not None:
            ansl.append(node.val)
            node = node.next

        while len(ansl)>1:
            if ansl.popleft() != ansl.pop():
                return False
        
        return True
```

The only differnce from the first answer is the usage of the type "deque". As I mentioned before, "pop" method of the type list is time-consuming. pop() takes the last value from the list, so it's not problem at all. But when it comes to pop(0), problem occurs. All value is shifted one by one, so it takes O(n) time. 

## 3. Given Solution #3


## Overall Review
