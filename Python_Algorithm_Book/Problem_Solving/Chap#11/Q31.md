# Q31 Top K Frequent Elements

01/30 p307 Q347 // q31

## Q

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in __any order__.

## Sample Input

### Example 1
__Input__: nums = [1,1,1,2,2,3], k = 2  
__Output__: [1,2]

### Example 2
__Input__: nums = [1], k = 1  
__Output__: [1]


## Constraints

- 1 <= `nums.length` <= 10<sup>5</sup>
- `k` is in the range [`1, the number of unique elements in the array`].
- It is __guaranteed__ that the answer is __unique__.


## 1. My Own Solution

```py
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        ans = []
        cnt = 0
        dic = sorted(collections.Counter(nums).items(), reverse=True,key=lambda item: item[1])
        print(dic)

        for tup in dic:
            ans.append(tup[0])
            cnt += 1
            if cnt >= k:
                break

        return ans
```

깔끔하게 counter 모듈 써서 풀었다. 사실 핵심은 value값(counter 모듈에서 나타나는 빈도)을 기준으로 한 sorting이다. 빈도 수가 높은 순으로 sorting 시킨다음, 맨 앞에서부터 k개의 key 값을 ans에 append해서 리턴했다. 읽으면 아마 한 방에 이해될 것이다.

늘 그랬듯이 런타임은 썩 좋지는 않다. 하위 34.9퍼 정도...?


## 2. Given Solution #1

```py
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        freqs = collections.Counter(nums)
        freqs_heap = []
        #insert to heap as negative

        for f in freqs:
            #f is the key, freqs[f] is the value(frequency)
            #insert it SWAPPED
            heapq.heapqpush(freqs_heap, (-freqs[f], f))

        topk = list()
        for _ in range(k):
            #pop out k-times
            #min-heap, so pop from the smallest value
            topk.append(heapq.heappop(freqs_heap[1]))

        return topk
```

힙에 대해 이해도가 조금 쌓여있으면 이해가 가는 풀이이다. freqs는 내 풀이처럼 counter 모듈을 이용한 풀이이다. 두 개의 for loop에서 이루어지는 일을 살펴보자.

1)for f in freqs  
heapq.heapqpush(A, B) : heapq 라이브러리의 heapqpush 함수를 가져온 것이다. B 원소를 A에 heapqpush 한다는 뜻이며 heapqpush로 삽입하게 되면 매번 heapify가 발생한다.  

**heapify는 특정 노드를 중심으로 그 근처의 트리들이 힙 성질을 만족하게 하는 작업이다. 내가 이용하는 heap은 min-heap이기 때문에, 완전 이진 트리 형태를 만족하면서 부모의 값(root)이 가장 작아야하고 자식 노드는 무조건 부모 노드보다 커야한다. 

아무튼 내 코드에서는 미리 만들어놓은 빈 리스트인 freqs_heap(A)에다가 튜플(-freqs[f], f)(B)를 heapqpush 하고 있다.


2) for _ in range(k)  
topk.append(headq.heappop(freqs_heap)[1]) : 

## 3. Given Solution #2

```py

```


## Overall Review
