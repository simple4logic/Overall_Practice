# Q30 Longest Substring Without Repeating Characters

01/28 p303 Q3 // q30

## Q

Given a string s, find the length of the longest substring without repeating characters.

## Sample Input

### Example 1
__Input__: s = "abcabcbb"  
__Output__: 3  
__Explanation__: The answer is "abc", with the length of 3.  

### Example 2
__Input__: s = "bbbbb"  
__Output__: 1  
__Explanation__: The answer is "b", with the length of 1.  

### Example 3
__Input__: s = "pwwkew"  
__Output__: 3  
__Explanation__: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.  


## Constraints

- 0 <= `s.length` <= 5 * 10<sup>4</sup>
- `s` consists of English letters, digits, symbols and spaces.


## 1. My Own Solution

```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        def expand(left: int, right : int) -> str:
            temp = set() #to check whether already appeared or not
            
            while left>=0 and right<len(s) and (s[left] not in temp) and (s[right] not in temp):
                if (right != left) and (s[right] == s[left]):
                    break
                temp.add(s[left])
                temp.add(s[right])
                left -= 1
                right +=1  
            return s[left + 1:right]

        result = ''
        for i in range(len(s)):
            result = max(result, expand(i, i+1), expand(i, i), key=len)

        return len(result)
```

이전에 풀었던 문제(Q6 가장 긴 팰린드롬 부분 문자열)에서 등장했던 풀이가 문득 떠올라서 응용해본 것이다. 이 풀이에서는 슬라이딩 윈도우를 이용해서 풀었다. String을 따라가면서 모든 문자마다 확장을 시도하고, max로 비교하는 방식이다. 구현 자체는 그리 어렵지 않았다. 간단히 설명하겠다.

palindrome에서는 새로 추가되는 좌우가 같은지 아닌지만 판단하면 됐지만, 여기선 기존에 등장했는지 아닌지를 계속 체크해야 한다. 따라서 set을 이용해서 확인했다.

```py
while left>=0 and right<len(s) and \
(s[left] not in temp) and (s[right] not in temp):
    if (right != left) and (s[right] == s[left]):
            break
```

매 loop마다 다음과 같은 사항들을 확인한다.
1. 좌우 edge에 닿지 않았는가
2. s[left] 원소가 set에 담겨있지 않은가
3. s[right] 원소가 set에 담겨있지 않은가  

추가적으로 break를 위해 right와 left가 같지 않은데 그 원소들 s[left], s[right]가 같은 경우에 거를 수 있도록 if-break를 넣었다. 나머지 원리들은 동일하다. 

이렇게 풀면 자력으로 풀리기는 풀리는데 런타임이 진짜 미쳤다... 너무 오래 걸린다. 슬라이딩 윈도우로 일일히 쓸고 지나가는 만큼 시간복잡도가 올라가는 것 같다. 그리고 이 챕터의 해시 테이블을 제대로 이용하지 못하는 것 같아서 여러모로 좀 아쉬운 풀이이다.

## 2. Given Solution #1

```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        used = {}
        max_len = start = 0
        for index, char in enumerate(s):
            if char in used and start <= used[char]:
                start = used[char] + 1 #char = key, index = value
            else:
                max_len = max(max_len, index - start + 1)

            used[char] = index
    
    return max_len
```

책에서 주어진 풀이는 index를 초점으로 전개해나가는 풀이이다. enumerate를 이용해서 given string을 각각의 char로 분해한다. 매번 index와 char을 이용해 for loop를 돌린다. 

1) char이 이미 used dic에 들어가 있을 경우에 start 포인트를 새로 갱신한다. 이때 새로운 시작점은 used dic에 저장되어있는 중복된 문자의 다음 위치이다. 뭔소린지 잘 이해가 안갈 수 있다. 예를들어, "a, b, c, a, b, c, b, b" 라는 test case가 있으면 네번째 a:3이 for loop에 들어가면 start는 index = 3 + 1이 아니라, 첫번째로 a가 나타난 0 + 1로 시작한다는 것이다. 그래야지만 누락되는 case 없이 다 검토할 수 있다.

2) char이 used dic에 들어있지 않은 새로운 문자인 경우에는 max_len을 갱신한다(max 함수를 이용해 기존 max와 비교). 이때 length는 지금 test한 문자의 index에서 (위에 언급된 방식으로 갱신되는)시작점인 start을 빼고 1을 더해서 구한다. "0, 1, 2" 까지면 사이즈가 3(=2 - 0 + 1)으로 계산되기 때문.


## 3. Given Solution #2

```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        charSet = set()
        left = 0
        result = 0
        for right in range(len(s)):
            while s[right] in charSet:
                charSet.remove(s[left])
                left = left+1
            charSet.add(s[right])
            result = max(result, right-left+1)
        return result
```

leetcode에서 긁어온 풀이.

## Overall Review

