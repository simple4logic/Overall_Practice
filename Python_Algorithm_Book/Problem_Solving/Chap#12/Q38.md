# Q38

<!--22.11.24 해결, 책 357p-->

## Q

## Sample Input

### Example 1


### Example 2


## Constraints


## 1. My Own Try

```py
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        ans = []

        def remove(list: List[List], element: List):
            tmplist = list[:]
            tmplist.remove(element)
            return tmplist
        
        def dfs(leftTicketList: List, path: List):
            if len(path) > len(tickets):
                ans.append(path)
                return
            
            #실제로 바로 pass하더라도, 모든 value들을 한 번씩 비교해보는건 시간을 많이 잡아먹는듯 하다
            for N in leftTicketList:
                if(path[-1] ==  N[0]):
                    dfs(remove(leftTicketList, N), path + [N[1]])


        dfs(tickets, ["A"])
        ans.sort()
        return ans[0]

# test set

a = Solution()

b1 = [["A", "B"], ["B", "E"], ["D", "E"], ["B", "D"], ["E", "B"]]
b2 = [["A", "B"], ["B", "F"], ["B", "C"], ["C", "B"]]
b3 = [["J", "S"], ["J", "A"], ["S", "A"], ["A", "J"], ["A", "S"]]

a.findItinerary(b1)
```

야심차게 시도한 첫 번째 풀이지만 개같이 실패... 이유는 time-out이었다. exmaple에 나와있는 input이나 나름대로 만들어서 해본 set에서는 잘 나왔었는데 역시 어마무시한 size의 test case가 들어가니까 실패했다. 나름대로 시간을 줄인 건데도 아웃이라서 이후 풀이부터는 답안을 조금 참고했다. 간단히 설명하면 DFS를 반복해서 모든 티켓을 이용하는 경로를 전부 ans에 append 해놓고, 그걸 다시 sort해서 첫 번째 원소를 리턴했다. 하지만 input이 매우 커지면서 "모든 경로를 전부 탐색"하는 방식이 문제였던 것 같다. 

## 2. My Own Solution

```py
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        ans = []
        graph = collections.defaultdict(list)

        for a, b in sorted(tickets):
            graph[a].append(b)

        def dfs(startfrom: str, path):
            if ans:
                return
            
            if len(path) > len(tickets):
                ans.append(path)
                return

            tmp = 0
            for N in graph[startfrom]:
                graph[startfrom].remove(N)
                dfs(N, path+[N])
                graph[startfrom].insert(tmp, N)
                tmp += 1

        start = "JFK"
        dfs(start, [start])
        # print(ans)
        return ans[0]
```

진짜 하루종일 고생한 끝에 겨우겨우 구해냈다. 순수하게 거의 4시간정도 쓴 것 같다. 일단 1번 시도가 거의 첫번째 try였는데 답을 구하기까지 굉장히 많은 실패가 있었다. 중요한 것만 몇개 꼽아보겠다.

- 1. graph로 자료 변환  
일단 자료의 형태를 graph로 바꾸어서 무의미하게 반복되는 loop를 최대한 많이 줄였다. for문에서 모든 N에 대해 lastDest와 비교하는 방식은 사실 단순무식한 N^x 꼴이라 타임아웃될 법 했다. 그래서 출발지끼리 묶은 딕셔너리를 만들었다.

- 2. if ans: return 추가  
위 풀이대로 해도 타임아웃이 떴다. for에서 처럼 완전 무의미한 루프는 줄었지만 그럼에도 불구하고 모든 트리를 다 탐색한다는 문제점이 있으므로 첫 번째 ans를 받은 순간 더 재귀를 진행할 이유가 없어서 ans에 원소가 하나라도 들어오면 사실상 재귀가 끝나도록 했다. 원래는 가능한 모든 경우의 수를 ans에 싹다 append하고 첫번째 요소를 return했다. 어짜피 그래프 만들때 sorted로 순서대로 그룹화했으니까 가장 첫번째로 append되는 경로가 무조건 답이었기 때문이다.

- 3. insert 위치 수정  
2번까지 진행하면 time-out은 안뜨는데 웬 쌩뚱맞은 wrong-answer가 뜬다. 진짜 모르겠다 하고 체념하려다가 발견해버렸다. line 19, 21을 보면 재귀에 들어가기 전에 타이밍을 맞춰서 미리 graph에서 빼고, 다음 재귀를 한다음에 그 재귀가 실패였으면 다시 append한다. 그래 바로 여기서 문제였다는 것이다. 이 방법은 이전 문제들에서 정답지가 보여준 예쁜 풀이여서 꼭 써보려고 했는데 하필 "사전식 배열" 문제에서 이걸 시도한게 패착이었다. 원래 insert 대신 append 썼을 때는 애가 분명이 돌았던 루프를 또 돌아서 ㅋㅋ 문제였고 이걸 치우려고 대충 맨 앞에 짱박아두려고 insert(0, element)를 했더니 이거 때문에 배열 순서가 바뀌어서 또 문제가 됐나보다. 설마 싶어서 tmp 변수 뚝딱 만들어서 임시로 index 역할을 하도록 시키고, remove했다가 빠진 그 자리에 그대로 insert 했더니 마침내 풀렸다.  

진짜 푸느라 힘들었다. 당연하지만 시간을 아주 많이 먹는다...


## 3. Given Solution #1

```py
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        graph = collections.defaultdict(list)

        for a, b in sorted(tickets):
            graph[a].append(b)

        route = []

        def dfs(a):
            while graph[a]:
                dfs(graph[a].pop(0))
            route.append(a)

        dfs('JFK')

        return route[::-1]
```

매번 느끼는 거지만 알고리즘 잘 짜는 사람들은 정말 '신'이다. 보면 굉장히 깔끔하고 간결하다. 코드를 짜다보면 예를 들어 특정 순간에서 exit해야 한다던지, index를 가져와야 한다는지 파생적인 문제가 생길 때가 있다. 그냥 변수 때려박아서 처리하면 내가 짠 ㅋㅋ 코드가 되는거고 아예 다른 문제가 생기지 않게 아주 깔끔한 구조로 짜면 이런 풀이가 완성되는 것이다. 하나씩 풀어서 보자. 위에서 graph로 정리한 것까지는 동일하다. dfs를 정의할 때 넣은 인자 a는 출발 지점으로 볼 수 있다. 모든 graph[출발지점]에 대해서 dfs를 시도한다. 그때 다시 인자로 넣는 것은 .pop(0)을 이용해서 ###### 보류. 왜지? 이해 막힘 ㅋㅋ


## Overall Review
